\documentclass[11pt,letterpaper]{article}

\usepackage[lmargin=0in,rmargin=2.5in]{geometry}
\setlength{\marginparwidth}{2.2in}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage[]{hyperref}
\hypersetup{
  colorlinks=false,
}
\usepackage{cleveref}
% \usepackage[disable]{todonotes}
\usepackage{todonotes}
\newcommand{\mytodo}[1]{\todo[size=\scriptsize]{#1}}

\usepackage{biblatex}
\addbibresource{library.bib}

\newtheorem{property}{Property}
\newtheorem{definition}{Definition}
\newtheorem{claim}{Claim}
\newtheorem{rrule}{Rule}
\newtheorem{thm}{Theorem}

% \title{Consensus with Permissionless Quorums in the Stellar Network}
% A reference to Cachin's paper:
\title{Asymmetric Distributed Trust in a Permissionless System}
\date{\today}
\author{Giuliano Losa\\giuliano@galois.com}

\begin{document}

\maketitle

\abstract{
A fail-prone system captures assumptions about which processes may fail together during an execution of a distributed system.
It is a useful tool for the design of distributed algorithms because a fail-prone system determines a canonical quorum system that, assuming it satisfies a property referred to as $Q^3$, allows to solve tasks such as reliable broadcast and consensus despite failures that remain within the assumptions.
However, fail-prone systems are not adapted to permissionless networks, where processes have no way to agree on failure assumptions beforehand.
In this paper, we propose federated fail-prone systems, which generalize fail-prone systems and are adapted to representing failure assumptions made by processes in a permissionless network.
Moreover, we show that, under a generalization of property $Q^3$, a federated fail-prone system determines a canonical quorum system allowing to solve tasks such as reliable broadcast and consensus despite failures that remain within the assumptions.
}

\newpage

\section{Introduction}

% \todo[inline]{The notion of federeated quorum system does not make sense. If process $p_i$ only trusts $P_i$, then why would it pick quorum members outside $P_i$? We could change the story and only focus on canonical quorum systems. Or maybe it can be understood as follows: a process ``hears'' by gossip from a set of nodes and then picks a quorum among the nodes it heard from; so the conditionn would be: for every slice choice ... , for every two quorums insider ... , ... }

A common problem in a distributed system is to solve a task (e.g.\ consensus) given some assumption about the possible failures that may occur.
Let us consider possible failures described by a fail-prone system~\cite{malkhiByzantineQuorumSystems1998}, also called adversary structure~\cite{hirtPlayerSimulationGeneral2000}.
A fail-prone system $\mathcal{F}=\left\{F_1,...,F_n\right\}$ is a set of fail-prone sets, where, for every $i$, the fail-prone set $F_i$ is a subset of processes.
$\mathcal{F}$ denotes the assumption that, in a given execution, the set of processes that actually fail is a subset of one of the fail-prone sets; we call such an execution a fail-compatible execution.

In the rest of the paper, we consider Byzantine failures, where a process that fails can behave arbitrarily; this models the worst-case scenario in which the failed processes are under control of an adversary which tries to disrupt the system.

To devise an algorithm that tolerates the failures described by a fail-prone system, one usually uses a quorum system for $\mathcal{F}$.
A quorum system for $\mathcal{F}$ is a set of quorums, which are sets of processes, such that: (a) the intersection of two quorums is not a subset of a fail-prone set and (b) for every fail-prone set $F$, there is a quorum disjoint from $F$.
This guarantees two crucial properties:
\begin{itemize}
  \item[Consistency] In every fail-compatible execution, every two quorums have a non-faulty member in common.
  \item[Availability] In every fail-compatible execution, there is at least one quorum that is exclusively non-faulty.
\end{itemize}
Given the Consistency and Availability properties, there are well-known algorithms for solving tasks such as read-write registers or consensus.

Given a fail-prone system $\mathcal{F}$, Hirt and Maurer~\cite{hirtPlayerSimulationGeneral2000} show that, if no three fail-prone sets cover the whole system, a property called Property $Q^3(\mathcal{F})$, then there exists a canonical quorum system $\overline{\mathcal{F}}$ for $\mathcal{F}$.\footnote{Hirt and Maurer also show that if $Q^3(\mathcal{F})$ does not hold, then there exists no quorum system for $\mathcal{F}$.}
$\overline{\mathcal{F}}$ is defined such that a set $Q$ is a quorum whenever $Q$ is the complement of a fail-prone set.
Thus, given assumptions about failures formalized in a fail-prone system $\mathcal{F}$ satisfying $Q^3\left(\mathcal{F}\right)$, $\overline{\mathcal{F}}$ is a natural quorum system to use to solve tasks such as consensus.
For example, consider a fail-prone system $\mathcal{F}_4$ consisting of 4 process where every singleton set is a fail-prone set (i.e.\ in every execution, at most one process fails).
By definition, the quorums of the canonical quorum system for $\mathcal{F}_4$ are all the sets of processes of cardinality 3.

One issue with the notion of fail-prone system is that it is not very useful in permissionless systems.
In a permissionless system, processes do not generally know what the set of participants is, and each process has a potentially different, partial view of the system.
Thus, it does not make sense for processes to (a) make assumptions about the entire system and (b) to all make the same assumptions.
For example, in a permissionless system, a fail-prone system where processes assume that at most some threshold $t$ (e.g.\ 1/3) of the system will fail does not yield a useful canonical quorum system: a quorum is supposed to be a set of more than $n$ times $t$ processes, where $n$ is the total number of processes, but there is no way to reliably know $n$.

In this paper, we make the following contributions:
\begin{enumerate}
  \item
    We propose \emph{federated fail-prone systems}, which generalize fail-prone systems and are adapted to permissionless systems.
    In contrast with fail-prone systems, where all processes make the same failure assumptions about the entire system, in a federated fail-prone system, each process (a) makes its own, personal failures assumptions and (b) makes failure assumptions only about a subset of the system.
  \item
    We show that given a federated fail-prone system satisfying a generalization of property $Q^3$, there is a canonical quorum system that can be used to solve consensus in a permissionless system.
    The canonical quorum system that we obtain is an instance of a Federated Byzantine Quorum System as defined by Mazières~\cite{MazieresStellarConsensusProtocol2015} and used in the Stellar Network to solve consensus.
\end{enumerate}


\section{Federated Fail-Prone Systems}
\label{sec:basic}

We consider a set of processes $\mathcal{P}=\left\{p_1,...,p_n\right\}$ in a message-passing system with Byzantine failures where processes do not know $\mathcal{P}$.
% Instead, each process $p_i$ knows and trusts a subset $T_i$ of the participants and makes failure assumptions about $T_i$ using a fail-prone system $\mathcal{F}_i$ over $T_i$ (i.e.\ $\mathcal{F}_i\subseteq 2^{T_i}$).
Instead, each process $p_i$ trusts a subset $T_i$ of the participants.
However, $p_i$ trusts members of $T_i$ only to the extent that they do not fail, and $p_i$ makes assumptions about those failures using a fail-prone system $\mathcal{F}_i$ over $T_i$ (i.e.\ $\mathcal{F}_i\subseteq 2^{T_i}$).
Note that two processes $p_i$ and $p_j$ may have disjoint trusted sets, i.e.\ nothing prevents that $T_i\cap T_j=\emptyset$.

% That is, in a given execution, a process is either well-behaved or faulty, and a faulty process can behave arbitrarily (including not taking steps).
% Processes do not know in advance which processes are well-behaved and which are not.
% We also assume that processes have a way to broadcast messages, and that a message broadcast by a well-behaved process is eventually delivered to all well-behaved processes.

We capture the processes' assumptions about failures using the notion of \emph{federated fail-prone system}.
A federated fail-prone system is an array $\mathbb{F}=\left[\left(T_1,\mathcal{F}_1\right),...,\left(T_n,\mathcal{F}_n\right)\right]$ that associates to each process $p_i$ a set of known peers $T_i$ and a fail-prone system $\mathcal{F}_i$ over $T_i$.
We now consider a fixed federated fail-prone system $\mathbb{F}$.

Note that federated fail-prone systems generalize fail-prone systems: a fail-prone system $\mathcal{F}$ is a federated fail-prone system where, for every process $p_i$, $T_i=\mathcal{P}$ and $\mathcal{F}_i=\mathcal{F}$. Similarly, federated fail-prone systems generalize the asymmetric fail-prone systems of Cachin and Tackmann~\cite{cachinAsymmetricDistributedTrust2019}.\todo{Is this the right place for this remark? Probably not. Why not at the end of this section? And show that the quorums obtained match.}

We say processes make correct assumptions in an execution if and only if the set $A$ of processes that are faulty in the execution is such that, for every process $p_i$ that does not fail, the members of $p_i$'s trusted set that fail are a subset of one of $p_i$'s fail-prone sets.
In other words, for every process $p_i$ in $\mathcal{P}\setminus A$, there exists $F\in\mathcal{F}_i$ such that $T_i\cap A \subseteq F$.
%More formally, the assumptions of the processes in a set $P$ are satisfied in an execution if and only if the set of processes that actually fail is a set $A$ such that, for every process $p_i$ in $P$ that does not fail (i.e.\ $p_i\not\in A$), there exists $F\in\mathcal{F}_i$ such that $T_i\cap A \subseteq F$.
We say that such an execution is a fail-compatible execution, and that the set $A$ is fail-compatible.
Moreover, a fail-compatible system is a set of execution that are all fail-compatible.

A federated quorum system $\mathbb{Q}$ for $\mathbb{F}$ is and array $\left[\mathcal{Q}_1,...,\mathcal{Q}_n\right]$ where, for every process $p_i$, $\mathcal{Q}_i$ is a quorum system over $\mathcal{P}$ (i.e.\ $Q_i\subseteq 2^{\mathcal{P}}$) and such that $\mathbb{Q}$ satisfies the Availability and Consistency properties below.
\begin{itemize}
  \item[Consistency] In every fail-compatible execution, for every two non-faulty processes $p_i$ and $p_j$, for every two quorums $Q_i$ of $p_i$ and $Q_j$ of $p_j$, $Q_i$ and $Q_j$ have a non-faulty member in common.
  \item[Availability] In every fail-compatible execution, every non-faulty process $p_i$  has at least one quorum that is exclusively non-faulty.
\end{itemize}

Our goal in the rest of this section is to define a property $Q^3(\mathbb{F})$ and a canonical quorum system $\overline{\mathbb{F}}$ such that if $Q^3(\mathbb{F})$ holds then $\overline{\mathbb{F}}$ satisfies the Availability and Consistency properties.

% Observe that, given a fail-compatible execution, for every process $p_i$, there is a fail-prone set $F$ of $p_i$ such that $T_i\setminus F$ does not fail.
% We call such a set a slice of $p_i$, i.e.\ a set of processes $S$ is a slice of $p_i$ if and only if there exists a fail-prone set $F$ of $p_i$ such that $S=T_i\setminus F$.
% The notion of slice is important because, in a fail-compatible system, if processes all broadcast, it is guaranteed that every process eventually hears from a set of processes $Q$ such that every member of $Q$ has a slice $S\subseteq Q$ (because $\mathcal{P}\setminus A$ is such a quorum).
% However, failed nodes can lie about their config...


Given a process $p_i$ and $F\in \mathcal{F}_i$, we say that the set $P_i\setminus F$ is a slice of $p_i$.
Note that, in a fail-compatible execution, every process that does not fail can count on one of its slices to be well-behaved.
Define a slice choice $\mathcal{S}$ as an array $\left[S_1,...,S_n\right]$ of slices, where, for every $i$, $S_i$ is a slice of $p_i$.
Define a slice-choice graph $G$ as a directed graph whose nodes are processes and such that there exists a slice choice $\left[S_1,...,S_n\right]$ such that, for every $p_i$ and $p_j$, there is an edge from $p_i$ to $p_j$ whenever $p_j\in S_i$. Note that a slice-choice array determines a slice-choice graph and vice versa.

Given a graph $G$ and a vertex $v$, we write $G^*(v)$ for set of vertices reachable in $G$ from $v$. Moreover, if $A$ is a subset of the vertices of $G$, we write $G-A$ for the graph obtained by removing from $G$ all edges that have an endpoint in $A$.

% Given a slice choice $\mathcal{S}=\left[S_1,...,S_n\right]$ and a set of processes $P$, we say that $P$ is closed under $\mathcal{S}$ if, for every $p_i$ in $P$, $S_i$ is a subset of $P$.

% Let $G_\mathbb{F}^*$ be the transitive closure of $G_\mathbb{F}$, i.e. $G_\mathbb{F}^*(p_i)$ is the set of processes reachable from $p_i$ in $G_\mathbb{F}$.

%Given the above preliminary definitions, we now define property $Q^3(\mathbb{F})$ for federated fail-prone systems.
Next, we define property $Q^3(\mathbb{F})$ for federated fail-prone systems.
\begin{definition}[Property $Q^3(\mathbb{F})$]
  Property $Q^3(\mathbb{F})$ holds if and only if for every two processes $p_i$ and $p_j$, for every two slice-choice graphs $G_i$ and $G_j$, for every fail-compatible set $A$, the set of vertices reachable from $p_i$ in $G_i-A$ intersects the set of vertices reachable from $p_j$ in $G_j-A$ (i.e.\ $\left(G_i-A\right)^*(p_i)$ and $\left(G_j-A\right)^*(p_j)$ intersect).
\end{definition}

Informally, Property $Q^3(\mathbb{F})$ says that two processes can always transitively hear from a third common process despite any failures compatible with the processes' failure assumptions.\todo{Even if faulty nodes lie about their slices!}

\begin{definition}[Canonical federated quorum system for $\mathbb{F}$]
  \label{def:canonical}
  Given a federated fail-prone system $\mathbb{F}$, we define $\overline{\mathbb{F}}=\left[\mathcal{Q}_1,...,\mathcal{Q}_n\right]$, where the set $\mathcal{Q}_i$ of quorums of $p_i$ is the biggest set such that, for every $Q\in\mathcal{Q}_i$,
  \begin{enumerate}
    \item $p_i$ has a slice that is a subset of $Q$, and
    \item there exists a fail-compatible set $A$ such that, for every process $p_j\in Q\setminus A$, $p_j$ has a slice that is a subset of $Q$.
  \end{enumerate}
\end{definition}


%Note that if we identify the notion of slice with the notion of quorum slice of Mazières~\cite{MazieresStellarConsensusProtocol2015}, then the definition of quorums above coincides with Mazières' definition; thus a Federated Byzantine Quorum System, as defined by Mazières, is isomorphic to a canonical federated quorum system for some $\mathbb{F}$.

\begin{claim}
  \label{thm:canonical}
  If $Q^3(\mathcal{F})$ holds, then the canonical federated quorum system for $\mathbb{F}$ satisfies the Availability and Consistency properties.
\end{claim}
\begin{proof}
  Consider a fail-compatible execution and let $A$ be the set of processes that fail during the execution.

  Let us first show that $\overline{\mathbb{F}}$ satisfies the Availability property.
  We must show that every process has a quorum that is exclusively non-faulty.
  By definition of fail-compatible execution, every process $p_i$ that does not fail has a slice $S_i$ that is disjoint from $A$.
  Thus, by definition of $\overline{\mathbb{F}}$, $\mathcal{P}\setminus A$ is a quorum of every process in $\mathcal{P}\setminus A$.
  By definition of $A$, $\mathcal{P}\setminus A$ is exclusively non-faulty, and thus every process has a quorum that is exclusively non-faulty.
  Note that we have not used the assumption that $Q^3(\mathcal{F})$ holds, and thus Availability holds regardless of whether $Q^3(\mathcal{F})$ holds.

  Let us now show that $\overline{\mathbb{F}}$ satisfies the Consistency property.
  Consider two processes $p_i$ and $p_j$, a quorum $Q_i$ of $p_i$, and a quorum $Q_j$ of $p_j$.
  We must show that $Q_i$ and $Q_j$ have a well-behaved member in common (i.e.\ a common member in $\mathcal{P}\setminus A$).
  By definition of $\overline{\mathbb{F}}$, for every quorum $Q$ of $p_i$, there exists a slice-choice array $\mathcal{S}_Q=\left[S_Q^1,...,S_Q^n\right]$ such that, for every $p_k\in Q$, $S_Q^k\subseteq Q$.
  Similarly, for every quorum $Q'$ of $p_j$, there exists a slice-choice array $\mathcal{S}_{Q'}=\left[S_{Q'}^1,...,S_{Q'}^n\right]$ such that, for every $p_k\in Q'$, $S_{Q'}^k\subseteq Q'$.
  Now consider the slice-choice graphs $G_Q$ and $G_{Q'}$ corresponding to $\mathcal{S}_Q$ and $\mathcal{S}_{Q'}$, respectively.
  By Property~$Q^3(\mathcal{F})$, we obtain that the set of vertices reachable from $p_i$ in $G_Q-A$ intersects the set of vertices reachable from $p_j$ in $G_{Q'}-A$.
  Moreover, observe that the set of vertices reachable from $p_i$ in $G_Q-A$ is a subset of $Q$.
  Similarly, observe that the set of vertices reachable from $p_j$ in $G_{Q'}-A$ is a subset of $Q'$.
  Thus, we conclude that $Q$ and $Q'$ have a well-behaved member in common.
\end{proof}

\subsection{Learning about Quorums}

Note that, in $\overline{\mathcal{F}}$, the set of quorums of a process $p_i$ depends on the slices of other processes.
However, in practice, $p_i$ does not know a priori the slices of other processes, and it can only learn about the slices of a process $p_j$ if $p_j$ tells $p_i$ what its slices are.
This introduces two problems: first, a process discovers its quorums dynamically at runtime; second, faulty processes can lie and equivocate about their slices.

\subsection{Befouled Processes}

Up to now, all well-behaved nodes were able to stay synchronized.
What if we have well-behaved nodes that...

\section{Related Work}

Hirt and Maurer~\cite{hirtPlayerSimulationGeneral2000} show that there exists a quorum system for $\mathcal{F}$ if and only if no three fail-prone sets cover the whole system; this property is called property $Q^3(\mathcal{F})$. Moreover, every fail-prone system that satisfies $Q^3(\mathcal{F})$ determines a canonical quorum system $\overline{\mathcal{F}}$ where $Q$ is a quorum if and only if $Q$ is the complement of a fail-prone set. %Thus, given a fail-prone systems satisfying $\mathcal{F}$, $\overline{\mathcal{F}}$ is a natural quorum system to use.

A limitation of quorum systems is that using a quorum system presupposes an existing agreement on who participates in the system and what constitutes a quorum.
This is difficult to achieve in an open, permissionless network, where arbitrary processor can join or leave without synchronization.
Some permissionless blockchains solve this problem with Proof of Stake, which, roughly, relies on a pre-existing agreement on who owns how much funds and defines a quorum as a set that collectively owns more than some threshold, e.g.\ two thirds, of the total amount of funds available; in terms of fail-prone system, this amounts to assuming that the fail-prone sets are the sets that collectively own less than one third of the total amount of funds.

Another idea is to let processes pick their own quorums for themselves. In a setting where processes have public, recognizable identities, one might hope that there is enough agreement in the real-world on some reputation-like quantity so that, if processes pick peers they deem reputable to create their quorums, the resulting quorums will be sufficiently overlapping and non-faulty. This leads to the idea of asymmetric fail-prone systems, as studied by Cachin and Tackmann~\cite{cachinAsymmetricDistributedTrust2019}.

Cachin and Tackmann generalize fail-prone systems to asymmetric fail-prone systems, where each process makes its own assumptions about which processes may fail together.
An asymmetric fail-prone system is an array of fail-prone systems $\mathbb{F}=\left[\mathcal{F}_1,...,\mathcal{F}_n\right]$ where $\mathcal{F}_i$ is a fail-prone system denoting the assumptions of process $p_i$.  Similarly to Hirt and Maurer, Cachin and Tackman define an asymmetric quorum system for $\mathbb{F}$, they generalize property $Q^3$ to asymmetric quorum systems, and they show that (a) $Q^3(\mathbb{F})$ holds if and only if there exists an asymmetric quorum system for $\mathbb{F}$ and (b) an asymmetric fail-prone system determines a canonical asymmetric quorum system for $\mathbb{F}$.

% as follows: $Q^3(\mathbb{F})$ holds if and only if for every two processes $p_i$ and $p_j$, for every $F_i^1, F_i^2\in \mathcal{F}_i$, $F_j^1, F_j^2\in \mathcal{F}_j$, $F_i^1\cup F_j^1\cup \left(F_i^2\cap F_j^2\right)$ do not cover the whole set.

The property $Q^3(\mathbb{F})$ of Cachin and Tackmann stipulates that for every two processes $p_i$ and $p_j$, for every two fail-prone sets $F_i^1$ and $F_i^2$ of $p_i$, for every two fail-prone sets $F_j^1$ and $F_j^2$ of $p_j$, we must have $\mathcal{P}\not\subseteq F_i^1\cup F_j^1\cup \left(F_i^2\cap F_j^2\right)$. Thus, unless every two processes in the system make compatible assumptions, in the sense of satisfying property $Q^3(\mathbb{F})$, it is not possible to obtain an asymmetric quorum system that tolerates failures within the bounds of the failure assumptions made by the processes. In practice, it is unclear to us whether there exists a pragmatic scheme to achieve Cachin and Tackmann's property $Q^3(\mathbb{F})$ in a permissionless network.
\todo{See also~\cite{alposHowTrustStrangers2021}}
\printbibliography

% \section{Related Work}

% Similarly, an asymmetric quorum system is a family of quorum systems $\mathbb{Q}=\left[\mathcal{Q}_1,...,\mathcal{Q}_n\right]$ where $\mathcal{Q}_i$ is the quorum system of process $p_i$. $\mathbb{Q}$ must be such that (a) for every two processes $p_i$ and $p_j$ and for every two quorums $Q_i$ of $p_i$ and $Q_j$ of $p_j$, $Q_i\cap Q_j$ contains a process which is not assumed faulty by both $p_i$ and $p_j$ (i.e. for every $F\in F_i$ and $F'\in F_j$, $Q_i\cap Q_j \not\subseteq F\cap F'$\todo{this is not the wording of Cachin, which seems confusing}), and (b) for every set of processes $F$ that $p_i$ assume may fail together, there is a quorum of $p_i$ that is disjoint from $F$. As in the case of traditional quorum systems, those conditions enable solving useful distributed computing tasks such as read-write registers and broadcast using well-known techniques. Moreover, Cachin and Tackmann show that property $Q^3(\mathcal{F})$ generalizes to asymmetric quorum systems as follows: $Q^3(\mathcal{F})$ holds if and only if for every two processes $p_i$ and $p_j$,



% \begin{center}
% \begin{tabular}{ |c|c| }
  % \hline
  % node & quorums \\
  % \hline
  % $n_1$ & \{  \\
  % \hline
  % $n_2$ & cell5 \\
  % \hline
  % $n_3$ & cell8 \\
  % \hline
  % $n_4$ & cell8 \\
  % \hline
  % $n_5$ & cell8 \\
  % \hline
% \end{tabular}
% \end{center}

\appendix

\section{From Fail-Prone Systems to Federated Fail-Prone Systems}

\todo[inline]{
Here the idea is motivate $Q^3$ and the definition of quorums by analogy.
So we'd start by presenting classical fail-prone systems, explaining why $Q^3$ is defined like it is, and then obtain the new $Q^3$ by analogy.
}

We consider a set of processes $\mathcal{P}=\left\{p_1,...,p_n\right\}$ in a message-passing system with Byzantine failures.
That is, in a given execution, a process is either well-behaved or faulty, and a faulty process can behave arbitrarily (including not taking steps).
Processes do not know in advance which processes are well-behaved and which are not.
% We also assume that processes have a way to broadcast messages, and that a message broadcast by a well-behaved process is eventually delivered to all well-behaved processes.

We assume that processes do not know what $\mathcal{P}$ is exactly.
Instead, each process $p_i$ trusts a subset $T_i$ of the participants.
However, $p_i$ trusts members of $T_i$ only to the extent that they do not fail, and $p_i$ makes assumptions about those failures using a fail-prone system $\mathcal{F}_i$ over $T_i$ (i.e.\ $\mathcal{F}_i\subseteq 2^{T_i}$).
Note that two processes $p_i$ and $p_j$ may have disjoint trusted sets, i.e.\ nothing prevents that $T_i\cap T_j=\emptyset$.

We capture the processes' assumptions about failures using the notion of \emph{federated fail-prone system}. A federated fail-prone system is an array $\mathbb{F}=\left[\left(T_1,\mathcal{F}_1\right),...,\left(T_n,\mathcal{F}_n\right)\right]$ that associates to each process $p_i$ a set of trusted peers $T_i$ and a fail-prone system $\mathcal{F}_i$ over $T_i$.
% We now consider a fixed such $\mathbb{F}$.

The question we now ask is whether a federated fail-prone system helps us obtain a quorum system which allows to solve tasks such as read-write register and consensus.
To answer this question, we will proceed by analogy with the fail-prone systems.

A fail-prone system $\mathcal{F}=\left\{F_1,...,F_n\right\}$ is a set of fail-prone sets, where, for every $i$, the fail-prone set $F_i$ is a subset of processes.
$\mathcal{F}$ denotes the assumption that, in a given execution, the set of processes that actually fail is a subset of one of the fail-prone sets.
We call such an execution a fail-compatible execution, and we call a system in which all execution are fail-compatible a fail-compatible system.

In a fail-compatible system with a reliable network, every well-behaved process is guaranteed to eventually hear from a quorum of processes, i.e.\ a set $Q$ of processes such that there exists a fail-prone set $F$ where $Q=\mathcal{P}\setminus F$.
This is the Availability property of quorum systems.
Thanks to the availability property, a process that never waits for more than a quorum is guaranteed never to wait forever.
However, in an algorithm in which processes never wait for more than a quorum, no meaningful synchronization can take place if quorums do not have well-behaved members in common.
Otherwise, we can split the system in two disjoint subsets that make progress on their own without ever hearing from each other except through the word of failed processes, which can lie and equivocate about what each set is doing.
When is it guaranteed that two quorums have a well-behaved member in common?
Since quorums are the complement of fail-prone sets, quorums are guaranteed to have well-behaved members in common if and only if no three fail-prone sets cover the whole system.

\end{document}
